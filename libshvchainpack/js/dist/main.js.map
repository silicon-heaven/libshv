{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///./rpcmessage.js","webpack:///./rpcvalue.js","webpack:///./cpon.js","webpack:///./cpcontext.js","webpack:///./chainpack.js","webpack:///./bint.js","webpack:///./test.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACJ;AACoC;AAChC;AACE;AACd;;AAE7B,oBAAoB,sDAAU;AAC9B,kBAAkB,kDAAQ;AAC1B,yBAAyB,0DAAe;AACxC,cAAc,0CAAI;AAClB,yBAAyB,0DAAe;AACxC,uBAAuB,wDAAa;AACpC,oBAAoB,gDAAU;AAC9B,mBAAmB,oDAAS;AAC5B,cAAc,0CAAI;;;;;;;;ACflB;AAAA;AAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,kCAAkC;AAC7E,6CAA6C,yCAAyC;AACtF,8CAA8C,0CAA0C;AACxF,4CAA4C,0CAA0C;;AAEtF,6CAA6C,sEAAsE;AACnH,kDAAkD,wDAAwD;;AAE1G,2CAA2C,uEAAuE;AAClH,iDAAiD,uDAAuD;;AAExG,0CAA0C,sEAAsE;AAChH,gDAAgD,sDAAsD;;AAEtG,0CAA0C,uEAAuE;AACjH,mDAAmD,0DAA0D;;AAE7G,0CAA0C,uEAAuE;AACjH,mDAAmD,0DAA0D;;AAE7G,yCAAyC,sEAAsE;AAC/G,+CAA+C,sDAAsD;;AAErG,4CAA4C,sDAAsD;AAClG,0CAA0C,kDAAkD;AAC5F,+CAA+C,uDAAuD;;AAEjF;;;;;;;;ACzDrB;AAAA;AAAA;AAAY;;AAE6B;;AAElC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,0CAAI;AACZ;;AAEA;AACA;AACA,cAAc,gDAAU;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC/GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAY;;AAE6B;AACJ;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAQ;AACrB;AACA,gBAAgB;AAChB;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,cAAc,kDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAQ;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB,kBAAkB;AAClB;;AAEA;AACA;AACA,gBAAgB,sDAAW;AAC3B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,6CAA6C;AAC7C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,2CAA2C;AAC3C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;;AAEA,gEAAgE;AAChE;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,iBAAiB,kDAAQ;AACzB;AACA,mBAAmB;AACnB;AACA;AACA,iBAAiB,kDAAQ;AACzB;;AAEA;AACA;AACA,iBAAiB,kDAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,sDAAW;AAC3B;;AAEA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO,kDAAQ,6CAA6C;AAC5D,OAAO,kDAAQ,0CAA0C;AACzD,OAAO,kDAAQ,+CAA+C;AAC9D,OAAO,kDAAQ,0CAA0C;AACzD,OAAO,kDAAQ,wCAAwC;AACvD,OAAO,kDAAQ,8CAA8C;AAC7D,OAAO,kDAAQ,gDAAgD;AAC/D,OAAO,kDAAQ,0CAA0C;AACzD,OAAO,kDAAQ,wCAAwC;AACvD,OAAO,kDAAQ,0CAA0C;AACzD,OAAO,kDAAQ,kDAAkD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;;AAEuC;;;;;;;;AC1vBvC;AAAA;AAAA;AAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;ACrGrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAY;;AAE6B;AACZ;;AAEtB;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,6CAA6C;AAC7C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD,8BAA8B,sBAAsB;AACpD,8BAA8B,sBAAsB;AACpD,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA,YAAY,0CAAI;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,gBAAgB,sDAAW;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,kGAAkG;AAClG,6DAA6D;AAC7D,yDAAyD;AACzD,uDAAuD;AACvD,6DAA6D;AAC7D,+DAA+D;AAC/D,yDAAyD;AACzD,uDAAuD;AACvD,yDAAyD;AACzD,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,sDAAW;AAC3B;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC5hBA;AAAA;AAAY;;AAEL;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,kBAAkB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;;;;;;;ACpJA;AAAA;AAAA;AAAY;;AAEyB;;AAE9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB;AACtB,OAAO,IAAI;AACX,OAAO,qCAAqC,MAAM,sBAAsB;AACxE,UAAU,QAAQ;AAClB;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,4BAA4B,SAAS;AACrC,oCAAoC,QAAQ;AAC5C,OAAO,gCAAgC,MAAM,IAAI;AACjD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAK,0BAA0B;AACnC;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,kDAAQ;AACrB;AACA;AACA;;AAEA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,kDAAQ;AACnB,WAAW,kDAAQ;AACnB,WAAW,kDAAQ;AACnB,WAAW,kDAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { RpcMessage } from './rpcmessage'\nimport { RpcValue } from './rpcvalue'\nimport { ChainPackWriter, ChainPackReader, ChainPack } from './chainpack'\nimport { Cpon, CponReader } from './cpon'\nimport { UnpackContext } from './cpcontext'\nimport { Test } from './test'\n\nwindow.RpcMessage = RpcMessage\nwindow.RpcValue = RpcValue\nwindow.ChainPackWriter = ChainPackWriter\nwindow.Cpon = Cpon\nwindow.ChainPackReader = ChainPackReader\nwindow.UnpackContext = UnpackContext\nwindow.CponReader = CponReader\nwindow.ChainPack = ChainPack\nwindow.Test = Test\n","\"use strict\"\n\nfunction RpcMessage(rpc_val)\n{\n\tif(typeof rpc_val === 'undefined')\n\t\tthis.rpcValue = new RpcValue();\n\telse if(typeof rpc_val === 'null')\n\t\tthis.rpcValue = null;\n\telse if(rpc_val && rpc_val.constructor.name === \"RpcValue\")\n\t\tthis.rpcValue = rpc_val;\n\telse\n\t\tthrow new TypeError(\"RpcMessage cannot be constructed with \" + typeof rpc_val)\n\n\tif(this.rpcValue) {\n\t\tif(!this.rpcValue.meta)\n\t\t\tthis.rpcValue.meta = {}\n\t\tif(!this.rpcValue.value)\n\t\t\tthis.rpcValue.value = {}\n\t\tthis.rpcValue.type = RpcValue.Type.IMap\n\t}\n}\n\nRpcMessage.TagRequestId = \"8\";\nRpcMessage.TagShvPath = \"9\";\nRpcMessage.TagMethod = \"10\";\n\nRpcMessage.KeyParams = \"1\";\nRpcMessage.KeyResult = \"2\";\nRpcMessage.KeyError = \"3\";\n\nRpcMessage.prototype.isValid = function() {return this.rpcValue? true: false; }\nRpcMessage.prototype.isRequest = function() {return this.requestId() && this.method(); }\nRpcMessage.prototype.isResponse = function() {return this.requestId() && !this.method(); }\nRpcMessage.prototype.isSignal = function() {return !this.requestId() && this.method(); }\n\nRpcMessage.prototype.requestId = function() {return this.isValid()? this.rpcValue.meta[RpcMessage.TagRequestId]: 0; }\nRpcMessage.prototype.setRequestId = function(id) {return this.rpcValue.meta[RpcMessage.TagRequestId] = id; }\n\nRpcMessage.prototype.shvPath = function() {return this.isValid()? this.rpcValue.meta[RpcMessage.TagShvPath]: null; }\nRpcMessage.prototype.setShvPath = function(val) {return this.rpcValue.meta[RpcMessage.TagShvPath] = val; }\n\nRpcMessage.prototype.method = function() {return this.isValid()? this.rpcValue.meta[RpcMessage.TagMethod]: null; }\nRpcMessage.prototype.setMethod = function(val) {return this.rpcValue.meta[RpcMessage.TagMethod] = val; }\n\nRpcMessage.prototype.params = function() {return this.isValid()? this.rpcValue.value[RpcMessage.KeyParams]: null; }\nRpcMessage.prototype.setParams = function(params) {return this.rpcValue.value[RpcMessage.KeyParams] = params; }\n\nRpcMessage.prototype.result = function() {return this.isValid()? this.rpcValue.value[RpcMessage.KeyResult]: null; }\nRpcMessage.prototype.setResult = function(result) {return this.rpcValue.value[RpcMessage.KeyResult] = result; }\n\nRpcMessage.prototype.error = function() {return this.isValid()? this.rpcValue.value[RpcMessage.KeyError]: null; }\nRpcMessage.prototype.setError = function(err) {return this.rpcValue.value[RpcMessage.KeyError] = err; }\n\nRpcMessage.prototype.toString = function() {return this.isValid() ? this.rpcValue.toString() : \"\"; }\nRpcMessage.prototype.toCpon = function() {return this.isValid()? this.rpcValue.toCpon(): \"\"; }\nRpcMessage.prototype.toChainPack = function() {return this.isValid()? this.rpcValue.toChainPack(): \"\"; }\n\nexport { RpcMessage }\n","\"use strict\"\n\nimport { CponWriter, Cpon } from './cpon'\n\nexport function RpcValue(value, meta, type)\n{\n\tif(value)\n\t\tthis.value = value;\n\tif(meta)\n\t\tthis.meta = meta;\n\tif(type) {\n\t\tthis.type = type;\n\t}\n\telse {\n\t\tif(typeof value == \"null\")\n\t\t\tthis.type = RpcValue.Type.Null;\n\t\telse if(typeof value == \"boolean\")\n\t\t\tthis.type = RpcValue.Type.Bool;\n\t\telse if(typeof value == \"string\") {\n\t\t\tthis.value = Cpon.stringToUtf8(value);\n\t\t\tthis.type = RpcValue.Type.String;\n\t\t}\n\t\telse if(Array.isArray(value))\n\t\t\tthis.type = RpcValue.Type.List;\n\t\telse if(typeof value == \"Object\") {\n\t\t\tif(value.constructor.name === \"Date\") {\n\t\t\t\tthis.value = {epochMsec: value.valueOf(), utcOffsetMin: -value.getTimezoneOffset()}\n\t\t\t\tthis.type = RpcValue.Type.DateTime;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.type = RpcValue.Type.Map;\n\t\t\t}\n\t\t}\n\t\telse if(Number.isInteger(value))\n\t\t\tthis.type = RpcValue.Type.Int;\n\t\telse if(Number.isFinite(value))\n\t\t\tthis.type = RpcValue.Type.Double;\n\t}\n}\n\nRpcValue.Type = Object.freeze({\n\t\"Null\": 1,\n\t\"Bool\": 2,\n\t\"Int\": 3,\n\t\"UInt\": 4,\n\t\"Double\": 5,\n\t\"Decimal\": 6,\n\t\"String\": 7,\n\t\"DateTime\": 8,\n\t\"List\": 9,\n\t\"Map\": 10,\n\t\"IMap\": 11,\n\t//\"Meta\": 11,\n})\n\nRpcValue.fromCpon = function(cpon)\n{\n\tlet unpack_context = null;\n\tif(typeof cpon === 'string') {\n\t\tunpack_context = new UnpackContext(Cpon.stringToUtf8(cpon));\n\t}\n\tif(unpack_context === null)\n\t\tthrow new TypeError(\"Invalid input data type\")\n\tlet rd = new CponReader(unpack_context);\n\treturn rd.read();\n}\n\nRpcValue.fromChainPack = function(data)\n{\n\tlet unpack_context = new UnpackContext(data);\n\tlet rd = new ChainPackReader(unpack_context);\n\treturn rd.read();\n}\n\nRpcValue.prototype.toInt = function()\n{\n\tswitch(this.type) {\n\t\tcase RpcValue.Type.Int:\n\t\tcase RpcValue.Type.UInt:\n\t\t\treturn this.value;\n\t\tcase RpcValue.Type.Decimal:\n\t\t\treturn this.value.mantisa * (10 ** this.value.exponent);\n\t\tcase RpcValue.Type.Double:\n\t\t\treturn (this.value >> 0);\n\t}\n\treturn 0;\n}\n\nRpcValue.prototype.toString = function()\n{\n\tlet ba = this.toCpon();\n\treturn Cpon.utf8ToString(ba);\n}\n\nRpcValue.prototype.toCpon = function()\n{\n\tlet wr = new CponWriter();\n\twr.write(this);\n\treturn wr.ctx.buffer();\n}\n\nRpcValue.prototype.toChainPack = function()\n{\n\tlet wr = new ChainPackWriter();\n\twr.write(this);\n\treturn wr.ctx.buffer();\n}\n\nRpcValue.prototype.isValid = function()\n{\n\treturn this.value && this.type;\n}\n","\"use strict\"\n\nimport { PackContext } from './cpcontext'\nimport { RpcValue } from './rpcvalue'\n\nfunction Cpon()\n{\n}\n\nCpon.ProtocolType = 2;\n\nCpon.utf8ToString = function(bytearray)\n{\n\tlet uint8_array = new Uint8Array(bytearray)\n\tvar str = '';\n\tfor (let i = 0; i < uint8_array.length; i++) {\n\t\tvar value = uint8_array[i];\n\n\t\tif (value < 0x80) {\n\t\t\tstr += String.fromCharCode(value);\n\t\t}\n\t\telse if (value > 0xBF && value < 0xE0) {\n\t\t\tstr += String.fromCharCode((value & 0x1F) << 6 | uint8_array[i + 1] & 0x3F);\n\t\t\ti += 1;\n\t\t}\n\t\telse if (value > 0xDF && value < 0xF0) {\n\t\t\tstr += String.fromCharCode((value & 0x0F) << 12 | (uint8_array[i + 1] & 0x3F) << 6 | uint8_array[i + 2] & 0x3F);\n\t\t\ti += 2;\n\t\t}\n\t\telse {\n\t\t\t// surrogate pair\n\t\t\tvar char_code = ((value & 0x07) << 18 | (uint8_array[i + 1] & 0x3F) << 12 | (uint8_array[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;\n\n\t\t\tstr += String.fromCharCode(char_code >> 10 | 0xD800, char_code & 0x03FF | 0xDC00);\n\t\t\ti += 3;\n\t\t}\n\t}\n\treturn str;\n}\n\nCpon.stringToUtf8 = function(str)\n{\n\tlet wr = new CponWriter();\n\twr.ctx.writeStringUtf8(str);\n\treturn wr.ctx.buffer();\n}\n\nfunction CponReader(unpack_context)\n{\n\tthis.ctx = unpack_context;\n}\n\nCponReader.prototype.skipWhiteIsignificant = function()\n{\n\tconst SPACE = ' '.charCodeAt(0);\n\tconst SLASH = '/'.charCodeAt(0);\n\tconst STAR = '*'.charCodeAt(0);\n\tconst LF = '\\n'.charCodeAt(0);\n\tconst KEY_DELIM = ':'.charCodeAt(0);\n\tconst FIELD_DELIM = ','.charCodeAt(0);\n\twhile(true) {\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b < 1)\n\t\t\treturn;\n\t\tif(b > SPACE) {\n\t\t\tif(b === SLASH) {\n\t\t\t\tthis.ctx.getByte();\n\t\t\t\tb = this.ctx.getByte();\n\t\t\t\tif(b === STAR) {\n\t\t\t\t\t//multiline_comment_entered;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tb = this.ctx.getByte();\n\t\t\t\t\t\tif(b === STAR) {\n\t\t\t\t\t\t\tb = this.ctx.getByte();\n\t\t\t\t\t\t\tif(b === SLASH)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(b === SLASH) {\n\t\t\t\t\t// to end of line comment entered;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tb = this.ctx.getByte();\n\t\t\t\t\t\tif(b === LF)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new TypeError(\"Malformed comment\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(b === KEY_DELIM) {\n\t\t\t\tthis.ctx.getByte();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(b === FIELD_DELIM) {\n\t\t\t\tthis.ctx.getByte();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.ctx.getByte();\n\t\t}\n\t}\n}\n\nCponReader.prototype.read = function()\n{\n\tlet ret = new RpcValue();\n\tthis.skipWhiteIsignificant();\n\tlet b = this.ctx.peekByte();\n\tif(b == '<'.charCodeAt(0)) {\n\t\tlet rv = new RpcValue();\n\t\tthis.readMap(rv, \">\".charCodeAt(0));\n\t\tret.meta = rv.value;\n\t}\n\n\tthis.skipWhiteIsignificant();\n\tb = this.ctx.peekByte();\n\t//console.log(\"CHAR:\", b, String.fromCharCode(b));\n\t// [0-9+-]\n\tif((b >= 48 && b <= 57) || b == 43 || b == 45) {\n\t\tthis.readNumber(ret);\n\t}\n\telse if(b == '\"'.charCodeAt(0)) {\n\t\tthis.readCString(ret);\n\t}\n\telse if(b == \"[\".charCodeAt(0)) {\n\t\tthis.readList(ret);\n\t\tret.type = RpcValue.Type.List;\n\t}\n\telse if(b == \"{\".charCodeAt(0)) {\n\t\tthis.readMap(ret);\n\t\tret.type = RpcValue.Type.Map;\n\t}\n\telse if(b == \"i\".charCodeAt(0)) {\n\t\tthis.ctx.getByte();\n\t\tb = this.ctx.peekByte();\n\t\tif(b == \"{\".charCodeAt(0)) {\n\t\t\tthis.readMap(ret);\n\t\t\tret.type = RpcValue.Type.IMap;\n\t\t}\n\t\telse {\n\t\t\tthrow TypeError(\"Invalid IMap prefix.\")\n\t\t}\n\t}\n\telse if(b == \"d\".charCodeAt(0)) {\n\t\tthis.ctx.getByte();\n\t\tb = this.ctx.peekByte();\n\t\tif(b == '\"'.charCodeAt(0)) {\n\t\t\tthis.readDateTime(ret);\n\t\t}\n\t\telse {\n\t\t\tthrow TypeError(\"Invalid DateTime prefix.\")\n\t\t}\n\t}\n\telse if(b == 't'.charCodeAt(0)) {\n\t\tthis.ctx.getBytes(\"true\");\n\t\tret.value = true;\n\t\tret.type = RpcValue.Type.Bool;\n\t}\n\telse if(b == 'f'.charCodeAt(0)) {\n\t\tthis.ctx.getBytes(\"false\");\n\t\tret.value = false;\n\t\tret.type = RpcValue.Type.Bool;\n\t}\n\telse if(b == 'n'.charCodeAt(0)) {\n\t\tthis.ctx.getBytes(\"null\");\n\t\tret.value = null;\n\t\tret.type = RpcValue.Type.Null;\n\t}\n\telse {\n\t\tthrow TypeError(\"Malformed Cpon input.\")\n\t}\n\treturn ret;\n}\n/*\n// see http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15\n// see https://stackoverflow.com/questions/16647819/timegm-cross-platform\n// see https://www.boost.org/doc/libs/1_62_0/boost/chrono/io/time_point_io.hpp\nCponReader.isLeapYear = function(year)\n{\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);\n}\n\nCponReader.daysFromYear0 = function(year)\n{\n\tyear--;\n\treturn 365 * year + ((year / 400) >> 0) - ((year/100) >> 0) + ((year / 4) >> 0);\n}\n\nCponReader.daysFrom1970 = function(year)\n{\n\treturn daysFromYear0(year) - days_from_0(1970);\n}\n\nCponReader.daysFromJan1st = function(year, month, mday)\n{\n\tconst days = [\n\t\t[ 0,31,59,90,120,151,181,212,243,273,304,334],\n\t\t[ 0,31,60,91,121,152,182,213,244,274,305,335]\n\t]\n\n\treturn days[CponReader.isLeapYear(year)? 1: 0][month] + mday - 1;\n}\n\nCponReader.timegm = function(year, month, mday, hour, min, sec)\n{\n\t// leap seconds are not part of Posix\n\tlet res = 0;\n\tyear = year + 1900;\n\t// month  0 - 11\n\t// mday  1 - 31\n\tres = CponReader.daysFrom1970(year);\n\tres += CponReader.daysFromJan1st(year, month, mday);\n\tres *= 24;\n\tres += hour;\n\tres *= 60;\n\tres += min;\n\tres *= 60;\n\tres += sec;\n\treturn res;\n}\n*/\nCponReader.prototype.readDateTime = function(rpc_val)\n{\n\n\tlet year = 0;\n\tlet month = 0;\n\tlet day = 1;\n\tlet hour = 0;\n\tlet min = 0;\n\tlet sec = 0;\n\tlet msec = 0;\n\tlet utc_offset = 0;\n\n\tthis.ctx.getByte(); // eat '\"'\n\tlet b = this.ctx.peekByte();\n\tif(b === '\"'.charCodeAt(0)) {\n\t\t// d\"\" invalid data time\n\t\tthis.ctx.getByte();\n\t\trpc_val.value = null;\n\t\trpc_val.type = RpcValue.Type.DateTime;\n\t\treturn;\n\t}\n\n\tyear = this.readInt();\n\n\tb = this.ctx.getByte();\n\tif(b !== '-'.charCodeAt(0))\n\t\tthrow new TypeError(\"Malformed year-month separator in DateTime\");\n\tmonth = this.readInt();\n\n\tb = this.ctx.getByte();\n\tif(b !== '-'.charCodeAt(0))\n\t\tthrow new TypeError(\"Malformed year-month separator in DateTime\");\n\tday = this.readInt();\n\n\tb = this.ctx.getByte();\n\tif(b !== ' '.charCodeAt(0) && b !== 'T'.charCodeAt(0))\n\t\tthrow new TypeError(\"Malformed date-time separator in DateTime\");\n\thour = this.readInt();\n\n\tb = this.ctx.getByte();\n\tif(b !== ':'.charCodeAt(0))\n\t\tthrow new TypeError(\"Malformed year-month separator in DateTime\");\n\tmin = this.readInt();\n\n\tb = this.ctx.getByte();\n\tif(b !== ':'.charCodeAt(0))\n\t\tthrow new TypeError(\"Malformed year-month separator in DateTime\");\n\tsec = this.readInt();\n\n\tb = this.ctx.peekByte();\n\tif(b === '.'.charCodeAt(0)) {\n\t\tthis.ctx.getByte();\n\t\tmsec = this.readInt();\n\t}\n\n\tb = this.ctx.peekByte();\n\tif(b == 'Z'.charCodeAt(0)) {\n\t\t// zulu time\n\t\tthis.ctx.getByte();\n\t}\n\telse if(b === '+'.charCodeAt(0) || b === '-'.charCodeAt(0)) {\n\t\t// UTC time offset\n\t\tthis.ctx.getByte();\n\t\tlet ix1 = this.ctx.index;\n\t\tlet val = this.readInt();\n\t\tlet n = this.ctx.index - ix1;\n\t\tif(!(n === 2 || n === 4))\n\t\t\tthrow new TypeError(\"Malformed TS offset in DateTime.\");\n\t\tif(n === 2)\n\t\t\tutc_offset = 60 * val;\n\t\telse if(n === 4)\n\t\t\tutc_offset = 60 * ((val / 100) >> 0) + (val % 100);\n\t\tif(b == '-'.charCodeAt(0))\n\t\t\tutc_offset = -utc_offset;\n\t}\n\n\tb = this.ctx.getByte();\n\tif(b !== '\"'.charCodeAt(0))\n\t\tthrow new TypeError(\"DateTime literal should be terminated by '\\\"'.\");\n\n\t//let epoch_sec = CponReader.timegm(year, month, mday, hour, min, sec);\n\tlet epoch_msec = Date.UTC(year, month - 1, day, hour, min, sec);\n\tepoch_msec -= utc_offset * 60000;\n\trpc_val.type = RpcValue.Type.DateTime;\n\trpc_val.value = {epochMsec: epoch_msec + msec, utcOffsetMin: utc_offset};\n}\n\nCponReader.prototype.readCString = function(rpc_val)\n{\n\tlet pctx = new PackContext();\n\tthis.ctx.getByte(); // eat '\"'\n\twhile(true) {\n\t\tlet b = this.ctx.getByte();\n\t\tif(b == '\\\\'.charCodeAt(0)) {\n\t\t\tb = this.ctx.getByte();\n\t\t\tswitch (b) {\n\t\t\tcase '\\\\'.charCodeAt(0): pctx.putByte(\"\\\\\"); break;\n\t\t\tcase '\"'.charCodeAt(0): pctx.putByte('\"'); break;\n\t\t\tcase 'b'.charCodeAt(0): pctx.putByte(\"\\b\"); break;\n\t\t\tcase 'f'.charCodeAt(0): pctx.putByte(\"\\f\"); break;\n\t\t\tcase 'n'.charCodeAt(0): pctx.putByte(\"\\n\"); break;\n\t\t\tcase 'r'.charCodeAt(0): pctx.putByte(\"\\r\"); break;\n\t\t\tcase 't'.charCodeAt(0): pctx.putByte(\"\\t\"); break;\n\t\t\tcase '0'.charCodeAt(0): pctx.putByte(0); break;\n\t\t\tdefault: pctx.putByte(b); break;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (b == '\"'.charCodeAt(0)) {\n\t\t\t\t// end of string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpctx.putByte(b);\n\t\t\t}\n\t\t}\n\t}\n\trpc_val.value = pctx.buffer();\n\trpc_val.type = RpcValue.Type.String;\n}\n\nCponReader.prototype.readList = function(rpc_val)\n{\n\tlet lst = []\n\tthis.ctx.getByte(); // eat '['\n\twhile(true) {\n\t\tthis.skipWhiteIsignificant();\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b == \"]\".charCodeAt(0)) {\n\t\t\tthis.ctx.getByte();\n\t\t\tbreak;\n\t\t}\n\t\tlet item = this.read()\n\t\tlst.push(item);\n\t}\n\trpc_val.value = lst;\n\trpc_val.type = RpcValue.Type.List;\n}\n\nCponReader.prototype.readMap = function(rpc_val, terminator = \"}\".charCodeAt(0))\n{\n\tlet map = {}\n\tthis.ctx.getByte(); // eat '{'\n\twhile(true) {\n\t\tthis.skipWhiteIsignificant();\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b == terminator) {\n\t\t\tthis.ctx.getByte();\n\t\t\tbreak;\n\t\t}\n\t\tlet key = this.read()\n\t\tif(!key.isValid())\n\t\t\tthrow new TypeError(\"Malformed map, invalid key\");\n\t\tthis.skipWhiteIsignificant();\n\t\tlet val = this.read()\n\t\tif(key.type === RpcValue.Type.String)\n\t\t\tmap[key.toString().slice(1, -1)] = val;\n\t\telse\n\t\t\tmap[key.toInt()] = val;\n\t}\n\trpc_val.value = map;\n}\n\nCponReader.prototype.readInt = function()\n{\n\tlet base = 10;\n\tlet val = 0;\n\tlet neg = 0;\n\tlet n = 0;\n\tfor (; ; n++) {\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b < 0)\n\t\t\tbreak;\n\t\tif (b === 43 || b === 45) { // '+','-'\n\t\t\tif(n != 0)\n\t\t\t\tbreak;\n\t\t\tthis.ctx.getByte();\n\t\t\tif(b === 45)\n\t\t\t\tneg = 1;\n\t\t}\n\t\telse if (b === 120) { // 'x'\n\t\t\tif(n === 1 && val !== 0)\n\t\t\t\tbreak;\n\t\t\tif(n !== 1)\n\t\t\t\tbreak;\n\t\t\tthis.ctx.getByte();\n\t\t\tbase = 16;\n\t\t}\n\t\telse if( b >= 48 && b <= 57) { // '0' - '9'\n\t\t\tthis.ctx.getByte();\n\t\t\tval *= base;\n\t\t\tval += b - 48;\n\t\t}\n\t\telse if( b >= 65 && b <= 70) { // 'A' - 'F'\n\t\t\tif(base !== 16)\n\t\t\t\tbreak;\n\t\t\tthis.ctx.getByte();\n\t\t\tval *= base;\n\t\t\tval += b - 65 + 10;\n\t\t}\n\t\telse if( b >= 97 && b <= 102) { // 'a' - 'f'\n\t\t\tif(base !== 16)\n\t\t\t\tbreak;\n\t\t\tthis.ctx.getByte();\n\t\t\tval *= base;\n\t\t\tval += b - 97 + 10;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(neg)\n\t\tval = -val;\n\treturn val;\n\n}\n\nCponReader.prototype.readNumber = function(rpc_val)\n{\n\tlet mantisa = 0;\n\tlet exponent = 0;\n\tlet decimals = 0;\n\tlet dec_cnt = 0;\n\tlet is_decimal = false;\n\tlet is_uint = false;\n\tlet is_neg = false;\n\n\tlet b = this.ctx.peekByte();\n\tif(b == 43) {// '+'\n\t\tis_neg = false\n\t\tb = this.ctx.getByte();\n\t}\n\telse if(b == 45) {// '-'\n\t\tis_neg = true\n\t\tb = this.ctx.getByte();\n\t}\n\n\tmantisa = this.readInt();\n\tb = this.ctx.peekByte();\n\twhile(b > 0) {\n\t\tif(b == \"u\".charCodeAt(0)) {\n\t\t\tis_uint = 1;\n\t\t\tthis.ctx.getByte();\n\t\t\tbreak;\n\t\t}\n\t\tif(b == \".\".charCodeAt(0)) {\n\t\t\tis_decimal = 1;\n\t\t\tthis.ctx.getByte();\n\t\t\tlet ix1 = this.ctx.index;\n\t\t\tdecimals = this.readInt();\n\t\t\t//if(n < 0)\n\t\t\t//\tUNPACK_ERROR(CCPCP_RC_MALFORMED_INPUT, \"Malformed number decimal part.\")\n\t\t\tdec_cnt = this.ctx.index - ix1;\n\t\t\tb = this.ctx.peekByte();\n\t\t\tif(b < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(b == 'e'.charCodeAt(0) || b == 'E'.charCodeAt(0)) {\n\t\t\tis_decimal = 1;\n\t\t\tthis.ctx.getByte();\n\t\t\tlet ix1 = this.ctx.index;\n\t\t\texponent = this.readInt();\n\t\t\tif(ix1 == this.ctx.index)\n\t\t\t\tthrow \"Malformed number exponetional part.\"\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tif(is_decimal) {\n\t\tfor (let i = 0; i < dec_cnt; ++i)\n\t\t\tmantisa *= 10;\n\t\tmantisa += decimals;\n\t\trpc_val.type = RpcValue.Type.Decimal;\n\t\tmantisa = is_neg? -mantisa: mantisa;\n\t\trpc_val.value = {\"mantisa\": mantisa, \"exponent\":  exponent - dec_cnt}\n\t}\n\telse if(is_uint) {\n\t\trpc_val.type = RpcValue.Type.UInt;\n\t\trpc_val.value = mantisa;\n\n\t}\n\telse {\n\t\trpc_val.type = RpcValue.Type.Int;\n\t\trpc_val.value = is_neg? -mantisa: mantisa;\n\t}\n}\n\nfunction CponWriter()\n{\n\tthis.ctx = new PackContext();\n}\n\nCponWriter.prototype.write = function(rpc_val)\n{\n\tif(!(rpc_val && rpc_val.constructor.name === \"RpcValue\"))\n\t\trpc_val = new RpcValue(rpc_val)\n\tif(rpc_val && rpc_val.constructor.name === \"RpcValue\") {\n\t\tif(rpc_val.meta) {\n\t\t\tthis.writeMeta(rpc_val.meta);\n\t\t}\n\t\tswitch (rpc_val.type) {\n\t\tcase RpcValue.Type.Null: this.ctx.writeStringUtf8(\"null\"); break;\n\t\tcase RpcValue.Type.Bool: this.writeBool(rpc_val.value); break;\n\t\tcase RpcValue.Type.String: this.writeCString(rpc_val.value); break;\n\t\tcase RpcValue.Type.UInt: this.writeUInt(rpc_val.value); break;\n\t\tcase RpcValue.Type.Int: this.writeInt(rpc_val.value); break;\n\t\tcase RpcValue.Type.Double: this.writeDouble(rpc_val.value); break;\n\t\tcase RpcValue.Type.Decimal: this.writeDecimal(rpc_val.value); break;\n\t\tcase RpcValue.Type.List: this.writeList(rpc_val.value); break;\n\t\tcase RpcValue.Type.Map: this.writeMap(rpc_val.value); break;\n\t\tcase RpcValue.Type.IMap: this.writeIMap(rpc_val.value); break;\n\t\tcase RpcValue.Type.DateTime: this.writeDateTime(rpc_val.value); break;\n\t\t/*\n\t\tcase RpcValue::Type::Invalid:\n\t\t\tif(WRITE_INVALID_AS_NULL) {\n\t\t\t\twrite_p(nullptr);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t*/\n\t\t}\n\t}\n}\n/*\nCponWriter.prototype.writeStringUtf8 = function(str)\n{\n\tfor (let i=0; i < str.length; i++) {\n\t\tlet charcode = str.charCodeAt(i);\n\t\tif (charcode < 0x80)\n\t\t\tthis.ctx.putByte(charcode);\n\t\telse if (charcode < 0x800) {\n\t\t\tthis.ctx.putByte(0xc0 | (charcode >> 6));\n\t\t\tthis.ctx.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t\telse if (charcode < 0xd800 || charcode >= 0xe000) {\n\t\t\tthis.ctx.putByte(0xe0 | (charcode >> 12));\n\t\t\tthis.ctx.putByte(0x80 | ((charcode>>6) & 0x3f));\n\t\t\tthis.ctx.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t\t// surrogate pair\n\t\telse {\n\t\t\ti++;\n\t\t\tcharcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)\n\t\t\tthis.ctx.putByte(0xf0 | (charcode >>18));\n\t\t\tthis.ctx.putByte(0x80 | ((charcode>>12) & 0x3f));\n\t\t\tthis.ctx.putByte(0x80 | ((charcode>>6) & 0x3f));\n\t\t\tthis.ctx.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t}\n}\n*/\nCponWriter.prototype.writeCString = function(buffer)\n{\n\tthis.ctx.writeStringUtf8(\"\\\"\");\n\tlet data = new Uint8Array(buffer);\n\tfor (let i=0; i < data.length; i++) {\n\t\tlet b = data[i];\n\t\tswitch(b) {\n\t\tcase 0:\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\0\");\n\t\t\tbreak;\n\t\tcase '\\\\'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\\\\\\");\n\t\t\tbreak;\n\t\tcase '\\t'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\b'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\b\");\n\t\t\tbreak;\n\t\tcase '\\r'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\r\");\n\t\t\tbreak;\n\t\tcase '\\n'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\"'.charCodeAt(0):\n\t\t\tthis.ctx.writeStringUtf8(\"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.ctx.putByte(b);\n\t\t}\n\t}\n\tthis.ctx.writeStringUtf8(\"\\\"\");\n}\n\nCponWriter.prototype.writeDateTime = function(dt)\n{\n\tif(!dt) {\n\t\tthis.ctx.writeStringUtf8('d\"\"');\n\t\treturn;\n\t}\n\tlet epoch_msec = dt.epochMsec;\n\tlet utc_offset = dt.utcOffsetMin;\n\tlet msec = epoch_msec + 60000 * utc_offset;\n\tlet s = new Date(msec).toISOString();\n\tlet rtrim = (msec % 1000)? 1: 5;\n\tthis.ctx.writeStringUtf8('d\"');\n\tfor (let i = 0; i < s.length-rtrim; i++)\n\t\tthis.ctx.putByte(s.charCodeAt(i));\n\tif(!utc_offset) {\n\t\tthis.ctx.writeStringUtf8('Z');\n\t}\n\telse {\n\t\tif(utc_offset < 0) {\n\t\t\tthis.ctx.writeStringUtf8('-');\n\t\t\tutc_offset = -utc_offset;\n\t\t}\n\t\telse {\n\t\t\tthis.ctx.writeStringUtf8('+');\n\t\t}\n\t\ts = ((utc_offset / 60) >> 0).toString().padStart(2, \"0\");\n\t\tif(utc_offset % 60)\n\t\t\ts += (utc_offset % 60).toString().padStart(2, \"0\");\n\t\tfor (let i = 0; i < s.length; i++)\n\t\t\tthis.ctx.putByte(s.charCodeAt(i));\n\t}\n\tthis.ctx.writeStringUtf8('\"');\n}\n\nCponWriter.prototype.writeBool = function(b)\n{\n\tthis.ctx.writeStringUtf8(b? \"true\": \"false\");\n}\n\nCponWriter.prototype.writeMeta = function(map)\n{\n\tthis.ctx.writeStringUtf8(\"<\");\n\tthis.writeMapContent(map);\n\tthis.ctx.writeStringUtf8(\">\")\n}\n\nCponWriter.prototype.writeIMap = function(map)\n{\n\tthis.ctx.writeStringUtf8(\"i{\");\n\tthis.writeMapContent(map);\n\tthis.ctx.writeStringUtf8(\"}\")\n}\n\nCponWriter.prototype.writeMap = function(map)\n{\n\tthis.ctx.writeStringUtf8(\"{\")\n\tthis.writeMapContent(map);\n\tthis.ctx.writeStringUtf8(\"}\")\n}\n\nCponWriter.prototype.writeMapContent = function(map)\n{\n\tlet i = 0;\n\tfor (let p in map) {\n\t\tif (map.hasOwnProperty(p)) {\n\t\t\tif(i++ > 0)\n\t\t\t\tthis.ctx.putByte(\",\".charCodeAt(0))\n\t\t\tlet c = p.charCodeAt(0);\n\t\t\tif(c >= 48 && c <= 57) {\n\t\t\t\tthis.writeInt(parseInt(p))\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.ctx.putByte('\"'.charCodeAt(0))\n\t\t\t\tthis.ctx.writeStringUtf8(p);\n\t\t\t\tthis.ctx.putByte('\"'.charCodeAt(0))\n\t\t\t}\n\t\t\tthis.ctx.writeStringUtf8(\":\")\n\t\t\tthis.write(map[p]);\n\t\t}\n\t}\n}\n\nCponWriter.prototype.writeList = function(lst)\n{\n\tthis.ctx.putByte(\"[\".charCodeAt(0))\n\tfor(let i=0; i<lst.length; i++) {\n\t\tif(i > 0)\n\t\t\tthis.ctx.putByte(\",\".charCodeAt(0))\n\t\tthis.write(lst[i])\n\t}\n\tthis.ctx.putByte(\"]\".charCodeAt(0))\n}\n\nCponWriter.prototype.writeUInt = function(num)\n{\n\tvar s = num.toString();\n\tthis.ctx.writeStringUtf8(s);\n\tthis.ctx.putByte(\"u\".charCodeAt(0))\n}\nCponWriter.prototype.writeInt = function(num)\n{\n\tvar s = num.toString();\n\tthis.ctx.writeStringUtf8(s);\n}\nCponWriter.prototype.writeDouble = function(num)\n{\n\tvar s = num.toString();\n\tif(s.indexOf(\".\") < 0)\n\t\ts += \".\"\n\tthis.ctx.writeStringUtf8(s);\n}\nCponWriter.prototype.writeDecimal = function(val)\n{\n\tlet mantisa = val.mantisa;\n\tlet exponent = val.exponent;\n\tif(mantisa < 0) {\n\t\tmantisa = -mantisa;\n\t\tthis.ctx.putByte(\"-\".charCodeAt(0));\n\t}\n\tlet str = mantisa.toString();\n\tlet n = str.length;\n\tlet dec_places = -exponent;\n\tif(dec_places > 0 && dec_places < n) {\n\t\tlet dot_ix = n - dec_places;\n\t\tstr = str.slice(0, dot_ix) + \".\" + str.slice(dot_ix)\n\t}\n\telse if(dec_places > 0 && dec_places <= 3) {\n\t\tlet extra_0_cnt = dec_places - n;\n\t\tlet str0 = \"0.\";\n\t\tfor (let i = 0; i < extra_0_cnt; ++i)\n\t\t\tstr0 += '0';\n\t\tstr = str0 + str;\n\t}\n\telse if(dec_places < 0 && n + exponent <= 9) {\n\t\tfor (let i = 0; i < exponent; ++i)\n\t\t\tstr += '0';\n\t\tstr += '.';\n\t}\n\telse if(dec_places == 0) {\n\t\tstr += '.';\n\t}\n\telse {\n\t\tstr += 'e' + exponent;\n\t}\n\tfor (let i = 0; i < str.length; ++i) {\n\t\tthis.ctx.putByte(str.charCodeAt(i));\n\t}\n}\n\nexport { Cpon, CponWriter, CponReader }\n","\"use strict\"\n\nfunction UnpackContext(uint8_array)\n{\n\tif(uint8_array.constructor.name === \"ArrayBuffer\")\n\t\tuint8_array = new Uint8Array(uint8_array)\n\telse if(uint8_array.constructor.name !== \"Uint8Array\")\n\t\tthrow new TypeError(\"UnpackContext must be constructed with Uint8Array\")\n\tthis.data = uint8_array\n\tthis.index = 0;\n}\n\nUnpackContext.prototype.getByte = function()\n{\n\tif(this.index >= this.data.length)\n\t\tthrow new RangeError(\"unexpected end of data\")\n\treturn this.data[this.index++]\n}\n\nUnpackContext.prototype.peekByte = function()\n{\n\tif(this.index >= this.data.length)\n\t\treturn -1\n\treturn this.data[this.index]\n}\n\nUnpackContext.prototype.getBytes = function(str)\n{\n\tfor (var i = 0; i < str.length; i++) {\n\t\tif(str.charCodeAt(i) != this.getByte())\n\t\t\tthrow new TypeError(\"'\" + str + \"'' expected\");\n\t}\n}\n\nfunction PackContext()\n{\n\t//this.buffer = new ArrayBuffer(PackContext.CHUNK_LEN)\n\tthis.data = new Uint8Array(0)\n\tthis.length = 0;\n}\n\nPackContext.CHUNK_LEN = 1024;\n\nPackContext.transfer = function(source, length)\n{\n\tif (!(source instanceof ArrayBuffer))\n\t\tthrow new TypeError('Source must be an instance of ArrayBuffer');\n\tif (length <= source.byteLength)\n\t\treturn source.slice(0, length);\n\tlet source_view = new Uint8Array(source)\n\tlet dest_view = new Uint8Array(new ArrayBuffer(length));\n\tdest_view.set(source_view);\n\treturn dest_view.buffer;\n}\n\nPackContext.prototype.putByte = function(b)\n{\n\tif(this.length >= this.data.length) {\n\t\tlet buffer = PackContext.transfer(this.data.buffer, this.data.length + PackContext.CHUNK_LEN)\n\t\tthis.data = new Uint8Array(buffer);\n\t}\n\tthis.data[this.length++] = b;\n}\n\nPackContext.prototype.writeStringUtf8 = function(str)\n{\n\tfor (let i=0; i < str.length; i++) {\n\t\tlet charcode = str.charCodeAt(i);\n\t\tif (charcode < 0x80)\n\t\t\tthis.putByte(charcode);\n\t\telse if (charcode < 0x800) {\n\t\t\tthis.putByte(0xc0 | (charcode >> 6));\n\t\t\tthis.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t\telse if (charcode < 0xd800 || charcode >= 0xe000) {\n\t\t\tthis.putByte(0xe0 | (charcode >> 12));\n\t\t\tthis.putByte(0x80 | ((charcode>>6) & 0x3f));\n\t\t\tthis.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t\t// surrogate pair\n\t\telse {\n\t\t\ti++;\n\t\t\tcharcode = ((charcode&0x3ff)<<10)|(str.charCodeAt(i)&0x3ff)\n\t\t\tthis.putByte(0xf0 | (charcode >>18));\n\t\t\tthis.putByte(0x80 | ((charcode>>12) & 0x3f));\n\t\t\tthis.putByte(0x80 | ((charcode>>6) & 0x3f));\n\t\t\tthis.putByte(0x80 | (charcode & 0x3f));\n\t\t}\n\t}\n}\n/*\nPackContext.prototype.bytes = function()\n{\n\treturn this.data.subarray(0, this.length)\n}\n*/\nPackContext.prototype.buffer = function()\n{\n\treturn this.data.buffer.slice(0, this.length)\n}\n\nexport { PackContext, UnpackContext }\n","\"use strict\"\n\nimport { PackContext } from './cpcontext'\nimport { BInt } from './bint'\n\nexport function ChainPack()\n{\n}\n\nChainPack.ProtocolType = 1;\n\nChainPack.CP_Null = 128;\nChainPack.CP_UInt = 129;\nChainPack.CP_Int = 130;\nChainPack.CP_Double = 131;\nChainPack.CP_Bool = 132;\n//ChainPack.CP_Blob_depr; // deprecated\nChainPack.CP_String = 134;\n//ChainPack.CP_DateTimeEpoch_depr; // deprecated\nChainPack.CP_List = 136;\nChainPack.CP_Map = 137;\nChainPack.CP_IMap = 138;\nChainPack.CP_MetaMap = 139;\nChainPack.CP_Decimal = 140;\nChainPack.CP_DateTime = 141;\nChainPack.CP_CString = 142;\nChainPack.CP_FALSE = 253;\nChainPack.CP_TRUE = 254;\nChainPack.CP_TERM = 255;\n\n// UTC msec since 2.2. 2018\n// Fri Feb 02 2018 00:00:00 == 1517529600 EPOCH\nChainPack.SHV_EPOCH_MSEC = 1517529600000;\nChainPack.INVALID_MIN_OFFSET_FROM_UTC = (-64 * 15);\n\nChainPack.isLittleEndian = (function() {\n\tlet buffer = new ArrayBuffer(2);\n\tnew DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n\t// Int16Array uses the platform's endianness.\n\treturn new Int16Array(buffer)[0] === 256;\n})();\n\nexport function ChainPackReader(unpack_context)\n{\n\tif(unpack_context.constructor.name === \"ArrayBuffer\")\n\t\tunpack_context = new UnpackContext(unpack_context)\n\telse if(unpack_context.constructor.name === \"Uint8Array\")\n\t\tunpack_context = new UnpackContext(unpack_context)\n\tif(unpack_context.constructor.name !== \"UnpackContext\")\n\t\tthrow new TypeError(\"ChainpackReader must be constructed with UnpackContext\")\n\tthis.ctx = unpack_context;\n}\n\nChainPackReader.prototype.read = function()\n{\n\tlet rpc_val = new RpcValue();\n\tlet packing_schema = this.ctx.getByte();\n\n\tif(packing_schema == ChainPack.CP_MetaMap) {\n\t\trpc_val.meta = this.readMap();\n\t\tpacking_schema = this.ctx.getByte();\n\t}\n\n\tif(packing_schema < 128) {\n\t\tif(packing_schema & 64) {\n\t\t\t// tiny Int\n\t\t\trpc_val.type = RpcValue.Type.Int;\n\t\t\trpc_val.value = packing_schema & 63;\n\t\t}\n\t\telse {\n\t\t\t// tiny UInt\n\t\t\trpc_val.type = RpcValue.Type.UInt;\n\t\t\trpc_val.value = packing_schema & 63;\n\t\t}\n\t}\n\telse {\n\t\tswitch(packing_schema) {\n\t\tcase ChainPack.CP_Null: {\n\t\t\trpc_val.type = RpcValue.Type.Null;\n\t\t\trpc_val.value = null;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_TRUE: {\n\t\t\trpc_val.type = RpcValue.Type.Bool;\n\t\t\trpc_val.value = true;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_FALSE: {\n\t\t\trpc_val.type = RpcValue.Type.Bool;\n\t\t\trpc_val.value = false;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_Int: {\n\t\t\trpc_val.value = this.readIntData()\n\t\t\trpc_val.type = RpcValue.Type.Int;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_UInt: {\n\t\t\trpc_val.value = this.readUIntData()\n\t\t\trpc_val.type = RpcValue.Type.UInt;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_Double: {\n\t\t\tlet data = new Uint8Array(8);\n\t\t\tfor (var i = 0; i < 8; i++)\n\t\t\t\tdata[i] = this.ctx.getByte();\n\t\t\trpc_val.value = new DataView(dat.buffer).getFloat64(0, true); //little endian\n\t\t\trpc_val.type = RpcValue.Type.Double;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_Decimal: {\n\t\t\tlet mant = this.readIntData();\n\t\t\tlet exp = this.readIntData();\n\t\t\trpc_val.value = {mantisa: mant, exponent: exp};\n\t\t\trpc_val.type = RpcValue.Type.Decimal;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_DateTime: {\n\t\t\tlet bi = this.readUIntDataHelper();\n\t\t\tlet lsb = bi.val[bi.val.length - 1]\n\t\t\tlet has_tz_offset = lsb & 1;\n\t\t\tlet has_not_msec = lsb & 2;\n\t\t\tbi.signedRightShift(2);\n\t\t\tlsb = bi.val[bi.val.length - 1]\n\n\t\t\tlet offset = 0;\n\t\t\tif(has_tz_offset) {\n\t\t\t\toffset = lsb & 0x7F;\n\t\t\t\tif(offset & 0x40) {\n\t\t\t\t\t// sign extension\n\t\t\t\t\toffset = offset - 128;\n\t\t\t\t}\n\t\t\t\tbi.signedRightShift(7);\n\t\t\t}\n\t\t\toffset *= 15;\n\t\t\tif(offset == ChainPack.INVALID_MIN_OFFSET_FROM_UTC) {\n\t\t\t\trpc_val.value = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet msec = bi.toNumber();\n\t\t\t\tif(has_not_msec)\n\t\t\t\t\tmsec *= 1000;\n\t\t\t\tmsec += ChainPack.SHV_EPOCH_MSEC;\n\n\t\t\t\trpc_val.value = {epochMsec: msec, utcOffsetMin: offset};\n\t\t\t}\n\t\t\trpc_val.type = RpcValue.Type.DateTime;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_Map: {\n\t\t\trpc_val.value = this.readMap();\n\t\t\trpc_val.type = RpcValue.Type.Map;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_IMap: {\n\t\t\trpc_val.value = this.readMap();\n\t\t\trpc_val.type = RpcValue.Type.IMap;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_List: {\n\t\t\trpc_val.value = this.readList();\n\t\t\trpc_val.type = RpcValue.Type.List;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_String: {\n\t\t\tlet str_len = this.readUIntData();\n\t\t\tlet arr = new Uint8Array(str_len)\n\t\t\tfor (var i = 0; i < str_len; i++)\n\t\t\t\tarr[i] = this.ctx.getByte()\n\t\t\trpc_val.value = arr.buffer;\n\t\t\trpc_val.type = RpcValue.Type.String;\n\t\t\tbreak;\n\t\t}\n\t\tcase ChainPack.CP_CString:\n\t\t{\n\t\t\t// variation of CponReader.readCString()\n\t\t\tlet pctx = new PackContext();\n\t\t\twhile(true) {\n\t\t\t\tlet b = this.ctx.getByte();\n\t\t\t\tif(b == '\\\\'.charCodeAt(0)) {\n\t\t\t\t\tb = this.ctx.getByte();\n\t\t\t\t\tswitch (b) {\n\t\t\t\t\tcase '\\\\'.charCodeAt(0): pctx.putByte(\"\\\\\"); break;\n\t\t\t\t\tcase '0'.charCodeAt(0): pctx.putByte(0); break;\n\t\t\t\t\tdefault: pctx.putByte(b); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (b == 0) {\n\t\t\t\t\t\t// end of string\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpctx.putByte(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trpc_val.value = pctx.buffer();\n\t\t\trpc_val.type = RpcValue.Type.String;\n\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tthrow new TypeError(\"ChainPack - Invalid type info: \" + packing_schema);\n\t\t}\n\t}\n\treturn rpc_val;\n}\n\nChainPackReader.prototype.readUIntDataHelper = function()\n{\n\tlet num = 0;\n\tlet head = this.ctx.getByte();\n\tlet bytes_to_read_cnt;\n\tif     ((head & 128) === 0) {bytes_to_read_cnt = 0; num = head & 127;}\n\telse if((head &  64) === 0) {bytes_to_read_cnt = 1; num = head & 63;}\n\telse if((head &  32) === 0) {bytes_to_read_cnt = 2; num = head & 31;}\n\telse if((head &  16) === 0) {bytes_to_read_cnt = 3; num = head & 15;}\n\telse {\n\t\tbytes_to_read_cnt = (head & 0xf) + 4;\n\t}\n\tlet bytes = new Uint8Array(bytes_to_read_cnt + 1)\n\tbytes[0] = num;\n\tfor (let i=0; i < bytes_to_read_cnt; i++) {\n\t\tlet r = this.ctx.getByte();\n\t\tbytes[i + 1] = r;\n\t}\n\treturn new BInt(bytes)\n}\n\nChainPackReader.prototype.readUIntData = function()\n{\n\tlet bi = this.readUIntDataHelper();\n\treturn bi.toNumber();\n}\n\nChainPackReader.prototype.readIntData = function()\n{\n\tlet bi = this.readUIntDataHelper();\n\tlet is_neg;\n\tif(bi.byteCount() < 5) {\n\t\tlet sign_mask = 0x80 >> bi.byteCount();\n\t\tis_neg = bi.val[0] & sign_mask;\n\t\tbi.val[0] &= ~sign_mask;\n\t}\n\telse {\n\t\tis_neg = bi.val[1] & 128;\n\t\tbi.val[1] &= ~128;\n\t}\n\tlet num = bi.toNumber();\n\tif(is_neg)\n\t\tnum = -num;\n\treturn num;\n}\n\nChainPackReader.prototype.readList = function()\n{\n\tlet lst = []\n\twhile(true) {\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b == ChainPack.CP_TERM) {\n\t\t\tthis.ctx.getByte();\n\t\t\tbreak;\n\t\t}\n\t\tlet item = this.read()\n\t\tlst.push(item);\n\t}\n\treturn lst;\n}\n\nChainPackReader.prototype.readMap = function()\n{\n\tlet map = {}\n\twhile(true) {\n\t\tlet b = this.ctx.peekByte();\n\t\tif(b == ChainPack.CP_TERM) {\n\t\t\tthis.ctx.getByte();\n\t\t\tbreak;\n\t\t}\n\t\tlet key = this.read()\n\t\tif(!key.isValid())\n\t\t\tthrow new TypeError(\"Malformed map, invalid key\");\n\t\tlet val = this.read()\n\t\tif(key.type === RpcValue.Type.String)\n\t\t\tmap[key.toString().slice(1, -1)] = val;\n\t\telse\n\t\t\tmap[key.toInt()] = val;\n\t}\n\treturn map;\n}\n\nexport function ChainPackWriter()\n{\n\tthis.ctx = new PackContext();\n}\n\nChainPackWriter.prototype.write = function(rpc_val)\n{\n\tif(!(rpc_val && rpc_val.constructor.name === \"RpcValue\"))\n\t\trpc_val = new RpcValue(rpc_val)\n\tif(rpc_val && rpc_val.constructor.name === \"RpcValue\") {\n\t\tif(rpc_val.meta) {\n\t\t\tthis.writeMeta(rpc_val.meta);\n\t\t}\n\t\tswitch (rpc_val.type) {\n\t\tcase RpcValue.Type.Null: this.ctx.putByte(ChainPack.CP_Null); break;\n\t\tcase RpcValue.Type.Bool: this.ctx.putByte(rpc_val.value? ChainPack.CP_TRUE: ChainPack.CP_FALSE); break;\n\t\tcase RpcValue.Type.String: this.writeString(rpc_val.value); break;\n\t\tcase RpcValue.Type.UInt: this.writeUInt(rpc_val.value); break;\n\t\tcase RpcValue.Type.Int: this.writeInt(rpc_val.value); break;\n\t\tcase RpcValue.Type.Double: this.writeDouble(rpc_val.value); break;\n\t\tcase RpcValue.Type.Decimal: this.writeDecimal(rpc_val.value); break;\n\t\tcase RpcValue.Type.List: this.writeList(rpc_val.value); break;\n\t\tcase RpcValue.Type.Map: this.writeMap(rpc_val.value); break;\n\t\tcase RpcValue.Type.IMap: this.writeIMap(rpc_val.value); break;\n\t\tcase RpcValue.Type.DateTime: this.writeDateTime(rpc_val.value); break;\n\t\tdefault:\n\t\t\t// better to write null than create invalid chain-pack\n\t\t\tthis.ctx.putByte(ChainPack.CP_Null);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//ChainPackWriter.MAX_BIT_LEN = Math.log(Number.MAX_SAFE_INTEGER) / Math.log(2);\n// logcal operator in JS works on 32 bit only\nChainPackWriter.MAX_BIT_LEN = 32;\n\t/*\n\t 0 ...  7 bits  1  byte  |0|s|x|x|x|x|x|x|<-- LSB\n\t 8 ... 14 bits  2  bytes |1|0|s|x|x|x|x|x| |x|x|x|x|x|x|x|x|<-- LSB\n\t15 ... 21 bits  3  bytes |1|1|0|s|x|x|x|x| |x|x|x|x|x|x|x|x| |x|x|x|x|x|x|x|x|<-- LSB\n\t22 ... 28 bits  4  bytes |1|1|1|0|s|x|x|x| |x|x|x|x|x|x|x|x| |x|x|x|x|x|x|x|x| |x|x|x|x|x|x|x|x|<-- LSB\n\t29+       bits  5+ bytes |1|1|1|1|n|n|n|n| |s|x|x|x|x|x|x|x| |x|x|x|x|x|x|x|x| |x|x|x|x|x|x|x|x| ... <-- LSB\n\t\t\t\t\t\t\t\t\t\t\tn ==  0 ->  4 bytes number (32 bit number)\n\t\t\t\t\t\t\t\t\t\t\tn ==  1 ->  5 bytes number\n\t\t\t\t\t\t\t\t\t\t\tn == 14 -> 18 bytes number\n\t\t\t\t\t\t\t\t\t\t\tn == 15 -> for future (number of bytes will be specified in next byte)\n\t*/\n\n\t// return max bit length >= bit_len, which can be encoded by same number of bytes\n\n// number of bytes needed to encode bit_len\nChainPackWriter.bytesNeeded = function(bit_len)\n{\n\tlet cnt;\n\tif(bit_len <= 28)\n\t\tcnt = ((bit_len - 1) / 7 | 0) + 1;\n\telse\n\t\tcnt = ((bit_len - 1) / 8 | 0) + 2;\n\treturn cnt;\n}\n\nChainPackWriter.expandBitLen = function(bit_len)\n{\n\tlet ret;\n\tlet byte_cnt = ChainPackWriter.bytesNeeded(bit_len);\n\tif(bit_len <= 28) {\n\t\tret = byte_cnt * (8 - 1) - 1;\n\t}\n\telse {\n\t\tret = (byte_cnt - 1) * 8 - 1;\n\t}\n\treturn ret;\n}\n\nChainPackWriter.prototype.writeUIntDataHelper = function(bint)\n{\n\tlet bytes = bint.val;\n\t//let byte_cnt = bint.byteCount();\n\n\tlet head = bytes[0];\n\tif(bytes.length < 5) {\n\t\tlet mask = (0xf0 << (4 - bytes.length)) & 0xff;\n\t\thead = head & ~mask;\n\t\tmask <<= 1;\n\t\tmask &= 0xff;\n\t\thead = head | mask;\n\t}\n\telse {\n\t\thead = 0xf0 | (bytes.length - 5);\n\t}\n\tthis.ctx.putByte(head);\n\tfor (let i = 1; i < bytes.length; ++i) {\n\t\tlet r = bytes[i];\n\t\tthis.ctx.putByte(r);\n\t}\n}\n\nChainPackWriter.prototype.writeUIntData = function(num)\n{\n\tlet bi = new BInt(num)\n\tlet bitcnt = bi.significantBitsCount();\n\tbi.resize(ChainPackWriter.bytesNeeded(bitcnt));\n\tthis.writeUIntDataHelper(bi);\n}\n\nChainPackWriter.prototype.writeIntData = function(snum)\n{\n\tlet neg = (snum < 0);\n\tlet num = neg? -snum: snum;\n\tlet bi = new BInt(num)\n\tlet bitcnt = bi.significantBitsCount() + 1;\n\tbi.resize(ChainPackWriter.bytesNeeded(bitcnt));\n\tif(neg) {\n\t\tif(bi.byteCount() < 5) {\n\t\t\tlet sign_mask = 0x80 >> bi.byteCount();\n\t\t\tbi.val[0] |= sign_mask;\n\t\t}\n\t\telse {\n\t\t\tbi.val[1] |= 128;\n\t\t}\n\t}\n\tthis.writeUIntDataHelper(bi);\n}\n\nChainPackWriter.prototype.writeUInt = function(n)\n{\n\tif(n < 64) {\n\t\tthis.ctx.putByte(n % 64);\n\t}\n\telse {\n\t\tthis.ctx.putByte(ChainPack.CP_UInt);\n\t\tthis.writeUIntData(n);\n\t}\n}\n\nChainPackWriter.prototype.writeInt = function(n)\n{\n\tif(n >= 0 && n < 64) {\n\t\tthis.ctx.putByte((n % 64) + 64);\n\t}\n\telse {\n\t\tthis.ctx.putByte(ChainPack.CP_Int);\n\t\tthis.writeIntData(n);\n\t}\n}\n\nChainPackWriter.prototype.writeDecimal = function(val)\n{\n\tthis.ctx.putByte(ChainPack.CP_Decimal);\n\tthis.writeIntData(val.mantisa);\n\tthis.writeIntData(val.exponent);\n}\n\nChainPackWriter.prototype.writeList = function(lst)\n{\n\tthis.ctx.putByte(ChainPack.CP_List);\n\tfor(let i=0; i<lst.length; i++)\n\t\tthis.write(lst[i])\n\tthis.ctx.putByte(ChainPack.CP_TERM);\n}\n\nChainPackWriter.prototype.writeMapData = function(map)\n{\n\tfor (let p in map) {\n\t\tif (map.hasOwnProperty(p)) {\n\t\t\tlet c = p.charCodeAt(0);\n\t\t\tif(c >= 48 && c <= 57) {\n\t\t\t\tthis.writeInt(parseInt(p))\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.writeJSString(p);\n\t\t\t}\n\t\t\tthis.write(map[p]);\n\t\t}\n\t}\n\tthis.ctx.putByte(ChainPack.CP_TERM);\n}\n\nChainPackWriter.prototype.writeMap = function(map)\n{\n\tthis.ctx.putByte(ChainPack.CP_Map);\n\tthis.writeMapData(map);\n}\n\nChainPackWriter.prototype.writeIMap = function(map)\n{\n\tthis.ctx.putByte(ChainPack.CP_IMap);\n\tthis.writeMapData(map);\n}\n\nChainPackWriter.prototype.writeMeta = function(map)\n{\n\tthis.ctx.putByte(ChainPack.CP_MetaMap);\n\tthis.writeMapData(map);\n}\n\nChainPackWriter.prototype.writeString = function(str)\n{\n\tthis.ctx.putByte(ChainPack.CP_String);\n\tlet arr = new Uint8Array(str)\n\tthis.writeUIntData(arr.length)\n\tfor (let i=0; i < arr.length; i++)\n\t\tthis.ctx.putByte(arr[i])\n}\n\nChainPackWriter.prototype.writeJSString = function(str)\n{\n\tthis.ctx.putByte(ChainPack.CP_String);\n\tlet pctx = new PackContext();\n\tpctx.writeStringUtf8(str);\n\tthis.writeUIntData(pctx.length)\n\tfor (let i=0; i < pctx.length; i++)\n\t\tthis.ctx.putByte(pctx.data[i])\n}\n\nChainPackWriter.prototype.writeDateTime = function(dt)\n{\n\tif(!dt || typeof(dt) !== \"object\" || dt.utcOffsetMin == ChainPack.INVALID_MIN_OFFSET_FROM_UTC) {\n\t\t// invalid datetime\n\t\tdt = {epochMsec: ChainPack.SHV_EPOCH_MSEC, utcOffsetMin: ChainPack.INVALID_MIN_OFFSET_FROM_UTC}\n\t}\n\n\tthis.ctx.putByte(ChainPack.CP_DateTime);\n\n\tlet msecs = dt.epochMsec;\n\tmsecs = msecs - ChainPack.SHV_EPOCH_MSEC;\n\tif(msecs < 0)\n\t\tthrow new RangeError(\"DateTime prior to 2018-02-02 are not supported in current ChainPack implementation.\");\n\n\tlet offset = (dt.utcOffsetMin / 15) & 0x7F;\n\n\tlet ms = msecs % 1000;\n\tif(ms == 0)\n\t\tmsecs /= 1000;\n\tlet bi = new BInt(msecs);\n\tif(offset != 0) {\n\t\tbi.leftShift(7);\n\t\tbi.val[bi.val.length - 1] |= offset;\n\t}\n\tbi.leftShift(2);\n\tif(offset != 0)\n\t\tbi.val[bi.val.length - 1] |= 1;\n\tif(ms == 0)\n\t\tbi.val[bi.val.length - 1] |= 2;\n\n\t// save as signed int\n\tlet bitcnt = bi.significantBitsCount() + 1;\n\tbi.resize(ChainPackWriter.bytesNeeded(bitcnt));\n\tthis.writeUIntDataHelper(bi);\n}\n","\"use strict\"\n\nexport function BInt(n)\n{\n\tif(Number.isInteger(n)) {\n\t\tthis.val = BInt.parseInt(n);\n\t}\n\telse if(n.constructor.name === \"Uint8Array\") {\n\t\tthis.val = n;\n\t}\n\telse {\n\t\tthrow TypeError(n + \" is not convertible to BInt\");\n\t}\n}\n\nBInt.divInt = function(n, d)\n{\n\tlet r = n % d;\n\tif(!Number.isInteger(r))\n\t\tthrow new RangeError(\"Number too big for current implementation of DIV function: \" + n + \" DIV \" + d)\n\treturn [(n - r) / d, r];\n}\n\nBInt.parseInt = function(num)\n{\n\tlet bytes = new Uint8Array(8);\n\tlet len = 0;\n\twhile(true) {\n\t\t[num, bytes[len++]] = BInt.divInt(num, 256)\n\t\tif(num == 0)\n\t\t\tbreak;\n\t}\n\tbytes = bytes.subarray(0, len)\n\tbytes.reverse();\n\treturn bytes\n}\n\nBInt.prototype.byteCount = function()\n{\n\tif(this.val)\n\t\treturn this.val.length;\n\treturn 0;\n}\n\nBInt.prototype.resize = function(byte_cnt)\n{\n\tif(this.val.constructor.name !== \"Uint8Array\")\n\t\tthrow TypeError(n + \" cannot be resized\");\n\tif(byte_cnt < this.val.length) {\n\t\tthis.val = this.val.subarray(this.val.length - byte_cnt)\n\t}\n\telse if(byte_cnt > this.val.length) {\n\t\tlet nbytes = new Uint8Array(byte_cnt)\n\t\tnbytes.set(this.val, byte_cnt - this.val.length)\n\t\tthis.val = nbytes\n\t}\n}\n\nBInt.prototype.resizeSigned = function(byte_cnt)\n{\n\tlet old_len = this.val.length;\n\tthis.resize(byte_cnt);\n\tif(byte_cnt > old_len) {\n\t\tif(this.val[byte_cnt - old_len] & 128) {\n\t\t\t// extend sign\n\t\t\tfor(let i = 0; i < byte_cnt - old_len; i++)\n\t\t\t\tthis.val[i] = 0xff;\n\t\t}\n\t}\n}\n\nBInt.prototype.significantBitsCount = function()\n{\n\tlet n = this.val[0];\n\tconst mask = 128;\n\tlet len = 8;\n\tfor (; n && !(n & mask); --len) {\n\t\tn <<= 1;\n\t}\n\tlet cnt = n? len: 0;\n\tcnt += 8 * (this.val.length - 1)\n\treturn cnt;\n}\n\nBInt.prototype.leftShift = function(cnt)\n{\n\tlet nbytes = new Uint8Array(this.val.length)\n\tnbytes.set(this.val)\n\tlet is_neg = nbytes[0] & 128;\n\n\tfor(let j=0; j<cnt; j++) {\n\t\tlet cy = 0;\n\t\tfor(let i=nbytes.length - 1; i >= 0; i--) {\n\t\t\tlet cy1 = nbytes[i] & 128;\n\t\t\tnbytes[i] <<= 1;\n\t\t\tif(cy)\n\t\t\t\tnbytes[i] |= 1\n\t\t\tcy = cy1\n\t\t}\n\t\tif(cy) {\n\t\t\t// prepend byte\n\t\t\tlet nbytes2 = new Uint8Array(nbytes.length + 1)\n\t\t\tnbytes2.set(nbytes, 1);\n\t\t\tnbytes = nbytes2\n\t\t\tnbytes[0] = 1\n\t\t}\n\t}\n\tif(is_neg) for(let i=0; i<cnt; i++) {\n\t\tlet mask = 128;\n\t\tfor(let j = 0; j < 8; j++) {\n\t\t\tif(nbytes[i] & mask) {\n\t\t\t\tthis.val = nbytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbytes[i] |= mask;\n\t\t\tmask >>= 1;\n\t\t}\n\t}\n\tthis.val = nbytes;\n}\n\nBInt.prototype.signedRightShift = function(cnt)\n{\n\tlet bytes = this.val;\n\tfor(let j=0; j<cnt; j++) {\n\t\tlet cy = 0;\n\t\tfor(let i=0; i < bytes.length; i++) {\n\t\t\tlet cy1 = bytes[i] & 1;\n\t\t\tif(i == 0) {\n\t\t\t\tbytes[i] >>>= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytes[i] >>= 1;\n\t\t\t\tif(cy)\n\t\t\t\t\tbytes[i] |= 128\n\t\t\t}\n\t\t\tcy = cy1\n\t\t}\n\t}\n}\n\nBInt.prototype.toNumber = function()\n{\n\tlet num = 0;\n\tfor (let i=0; i < this.val.length; i++) {\n\t\tnum = (num * 256) + this.val[i];\n\t}\n\treturn num;\n}\n","\"use strict\"\n\nimport { RpcValue } from './rpcvalue'\n\nexport class Test\n{\n\tcheckEq(e1, e2, msg)\n\t{\n\t\t//console.log((e1 === e2)? \"OK\": \"ERROR\", \":\", e1, \"vs.\", e2)\n\t\tif(e1 === e2)\n\t\t\treturn;\n\t\tif(msg)\n\t\t\tthrow msg;\n\t\telse\n\t\t\tthrow \"test check error: \" + e1 + \" === \" + e2\n\t}\n\n\ttestConversions()\n\t{\n\t\tfor(const lst of [\n\t\t\t[(2**31 - 1) + \"u\", null],\n\t\t\t//[(2**32 - 1) + \"u\", null],  // too big for JS bitwise operations\n\t\t\t[\"\" + (2**31 - 1), null],\n\t\t\t[\"\" + (-(2**30 - 1)), null],\n\t\t\t[\"\" + (2**53 - 1), null], // Number.MAX_SAFE_INTEGER\n\t\t\t[\"\" + (-(2**53 - 1)), null], // Number.MIN_SAFE_INTEGER\n\t\t\t//[\"\" + (2**32 - 1), null], // too big for JS bitwise operations\n\t\t\t[\"true\", null],\n\t\t\t[\"false\", null],\n\t\t\t[\"null\", null],\n\t\t\t[\"1u\", null],\n\t\t\t[\"134\", null],\n\t\t\t[\"7\", null],\n\t\t\t[\"-2\", null],\n\t\t\t[\"0xab\", \"171\"],\n\t\t\t[\"-0xCD\", \"-205\"],\n\t\t\t[\"0x1a2b3c4d\", \"439041101\"],\n\t\t\t[\"223.\", null],\n\t\t\t[\"2.30\", null],\n\t\t\t[\"12.3e-10\", \"123e-11\"],\n\t\t\t[\"-0.00012\", \"-12e-5\"],\n\t\t\t[\"-1234567890.\", \"-1234567890.\"],\n\t\t\t[\"\\\"foo\\\"\", null],\n\t\t\t[\"[]\", null],\n\t\t\t[\"[1]\", null],\n\t\t\t[\"[1,]\", \"[1]\"],\n\t\t\t[\"[1,2,3]\", null],\n\t\t\t[\"[[]]\", null],\n\t\t\t[\"{\\\"foo\\\":\\\"bar\\\"}\", null],\n\t\t\t[\"i{1:2}\", null],\n\t\t\t[\"i{\\n\\t1: \\\"bar\\\",\\n\\t345u : \\\"foo\\\",\\n}\", \"i{1:\\\"bar\\\",345:\\\"foo\\\"}\"],\n\t\t\t[\"[1u,{\\\"a\\\":1},2.30]\", null],\n\t\t\t[\"<1:2>3\", null],\n\t\t\t[\"[1,<7:8>9]\", null],\n\t\t\t[\"<>1\", null],\n\t\t\t[\"<8:3u>i{2:[[\\\".broker\\\",<1:2>true]]}\", null],\n\t\t\t[\"<1:2,\\\"foo\\\":\\\"bar\\\">i{1:<7:8>9}\", null],\n\t\t\t[\"<1:2,\\\"foo\\\":<5:6>\\\"bar\\\">[1u,{\\\"a\\\":1},2.30]\", null],\n\t\t\t[\"i{1:2 // comment to end of line\\n}\", \"i{1:2}\"],\n\t\t\t[`/*comment 1*/{ /*comment 2*/\n\t\t\t\\t\\\"foo\\\"/*comment \\\"3\\\"*/: \\\"bar\\\", //comment to end of line\n\t\t\t\\t\\\"baz\\\" : 1,\n\t\t\t/*\n\t\t\t\\tmultiline comment\n\t\t\t\\t\\\"baz\\\" : 1,\n\t\t\t\\t\\\"baz\\\" : 1, // single inside multi\n\t\t\t*/\n\t\t\t}`, \"{\\\"foo\\\":\\\"bar\\\",\\\"baz\\\":1}\"],\n\t\t\t//[\"a[1,2,3]\", \"[1,2,3]\"], // unsupported array type\n\t\t\t[\"<1:2>[3,<4:5>6]\", null],\n\t\t\t[\"<4:\\\"svete\\\">i{2:<4:\\\"svete\\\">[0,1]}\", null],\n\t\t\t['d\"2019-05-03T11:30:00-0700\"', 'd\"2019-05-03T11:30:00-07\"'],\n\t\t\t['d\"\"', null],\n\t\t\t['d\"2018-02-02T00:00:00Z\"', null],\n\t\t\t['d\"2027-05-03T11:30:12.345+01\"', null],\n\t\t\t])\n\t\t{\n\t\t\tlet cpon1 = lst[0]\n\t\t\tlet cpon2 = lst[1]? lst[1]: cpon1;\n\n\t\t\tlet rv1 = RpcValue.fromCpon(cpon1);\n\t\t\tlet cpn1 = rv1.toString();\n\t\t\tlog(cpon1, \"\\t--cpon------>\\t\", cpn1)\n\t\t\tthis.checkEq(cpn1, cpon2);\n\n\t\t\tlet cpk1 = rv1.toChainPack();\n\t\t\tlet rv2 = RpcValue.fromChainPack(cpk1);\n\t\t\tlet cpn2 = rv2.toString();\n\t\t\tlog(cpn1, \"\\t--chainpack->\\t\", cpn2, \"\\n\")\n\t\t\tthis.checkEq(cpn1, cpn2);\n\t\t}\n\t}\n\n\ttestDateTime()\n\t{\n\t\t// same points in time\n\t\tlet v1 = RpcValue.fromCpon('d\"2017-05-03T18:30:00Z\"');\n\t\tlet v2 = RpcValue.fromCpon('d\"2017-05-03T22:30:00+04\"');\n\t\tlet v3 = RpcValue.fromCpon('d\"2017-05-03T11:30:00-0700\"');\n\t\tlet v4 = RpcValue.fromCpon('d\"2017-05-03T15:00:00-0330\"');\n\t\tthis.checkEq(v1.value.epochMsec, v2.value.epochMsec);\n\t\tthis.checkEq(v2.value.epochMsec, v3.value.epochMsec);\n\t\tthis.checkEq(v3.value.epochMsec, v4.value.epochMsec);\n\t\tthis.checkEq(v4.value.epochMsec, v1.value.epochMsec);\n\t}\n\n\tstatic run()\n\t{\n\t\t//try {\n\t\t\t/*\n\t\t\tfor(let i=0; i<7; i++) {\n\t\t\t\tlog(\"---------\", i, '---------------')\n\t\t\t\tfor(const n of [1,255,256,65535, 65536, -1, -255, -65535, -65536]) {\n\t\t\t\t\tlet bytes1 = ChainPack.uIntToBBE(n)\n\t\t\t\t\tlet bytes2 = ChainPack.rotateLeftBBE(bytes1, i)\n\t\t\t\t\tlog(n, \"<<\", i, '\\t', bytes1, \"->\", bytes2)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t\t*/\n\t\t\tlet t = new Test();\n\n\t\t\tt.testConversions();\n\t\t\tt.testDateTime();\n\n\t\t\tlog(\"PASSED\")\n\t\t//}\n\t\t//catch(err) {\n\t\t//\tlog(\"FAILED:\", err)\n\t\t//}\n\t}\n}\n"],"sourceRoot":""}